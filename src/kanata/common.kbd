;; This doesn't necessarily reflect the layout of keyboards I own
;; It just represents a lowest common denominator of keys that all my
;; keyboards should have, organized in a familiar layout.
;;
;; The rest of the file can (only) assume the presence of these keys.
;;
;; NOTE: the `fn` key is processed by Kanata only on macOS. AFAIK kanata does
;; not support conditional key in `defsrc`. So, using platform is the ugly
;; workaround. Also, since `fn` is not supported, what to use in its place?
;; Just picked a random placeholder key that I'm unlikely going to use, i.e.
;; EjectCD.
;; The other approach that doesn't require the EjectCD key placeholder would
;; lead to defsrc on macos and on linux to have different number of keys.
;; Then I'd have to refactor all the `deflayer`s in this file into `deflayermap`.
;; But I like `deflayer`.
(platform (macos)
  (defsrc
    grv   1    2    3    4    5    6    7    8    9    0    -    =    bspc
    tab   q    w    e    r    t    y    u    i    o    p    [    ]    \
    caps  a    s    d    f    g    h    j    k    l    ;    '    ret
    lsft  z    x    c    v    b    n    m    ,    .    /    rsft
    lctl  fn   lmet lalt      spc            ralt rmet rctl
  )
)
(platform (linux win winiov2 wintercept)
  (defsrc
    grv   1    2    3    4    5    6    7    8    9    0    -    =    bspc
    tab   q    w    e    r    t    y    u    i    o    p    [    ]    \
    caps  a    s    d    f    g    h    j    k    l    ;    '    ret
    lsft  z    x    c    v    b    n    m    ,    .    /    rsft
    lctl  EjectCD   lmet lalt      spc            ralt rmet rctl
  )
)

;; A+J is audio decrease
;; A+K is audio increase
;; A+Space is mute toggle
;; M+J is microphone increase
;; M+K is microphone decrease
;; M+Space is microphone toggle
;; P is the Print key
;; B+J is brightness decrease
;; B+K is brightness increase
(deflayer alt
  XX    mlft mmid mrgt XX   XX   XX   XX   XX   XX   XX   XX   XX   XX
  XX    XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX
  XX    @cha XX   XX   XX   XX   XX   @chj @chk XX   XX   XX   XX
  XX    XX   XX   XX   XX   @chb XX   @chm XX   XX   XX   XX
  XX    XX   XX   XX        @chspc         XX   XX   XX
)

(defalias
  cha (chord alt-chords a)
  chb (chord alt-chords b)
  chm (chord alt-chords m)
  chj (chord alt-chords j)
  chk (chord alt-chords k)
  chspc (chord alt-chords spc)
)

;; Why use macro?
;; See docs section "Input chords > Release behaviour"
;; It still kinda sucks. But just adding more layers instead of using defchords
;; is better. Anyway, let's accept this for now.
(defchords alt-chords 500
  (a j) (macro VolumeUp)
  (a k) (macro VolumeDown)
  (a spc) (macro VolumeMute)
  ;; Mic keys seem to be not supported yet.
  (m j) XX
  (m k) XX
  (b j) (macro brup)
  (b k) (macro brdown)
)

(deflayer mouse
  XX    mlft mmid mrgt XX   XX   XX   XX   XX   XX   XX   XX   XX   XX
  XX    XX   @ma↑ XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX
  XX    @ma← @ma↓ @ma→ XX   XX   XX   mlft mmid mrgt XX   XX   XX
  _     XX   XX   XX   XX   XX   XX   XX   @slw @fst XX   XX
  _     _    _    _         @l_mousewheel  XX   XX   XX
)

(deflayer mousewheel
  XX    mlft mmid mrgt XX   XX   XX   mlft mmid mrgt XX   XX   XX   XX
  XX    XX   @mwu XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX
  XX    @mwl @mwd @mwr XX   XX   XX   XX   XX   XX   XX   XX   XX
  _     XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX
  _     _    _    _         XX   XX   XX   XX
)

(defalias
  l_alt (layer-while-held alt)
)

(defalias
  l_mouse (layer-while-held mouse)
)

(defalias
  l_mousewheel (layer-while-held mousewheel)
)

(defalias
  ;; mouse layer or caps
  moc (tap-hold 200 200 caps @l_mouse)
)

(defalias
  ms↑ (movemouse-up 4 8)
  ms← (movemouse-left 4 8)
  ms↓ (movemouse-down 4 8)
  ms→ (movemouse-right 4 8)

  fst (movemouse-speed 150)
  slw (movemouse-speed 15)

  ;; $interval Number of milliseconds between move activations.
  ;; Depends on my reaction time. But should be small for cursor to feel smooth
  ;; when distance is high.
  ;;
  ;; $acceletaion-time Number of milliseconds until max distance per activation is reached.
  ;;
  ;; $min Initial distance to travel per activation in unit of pixels.
  ;; Close to the most fine-grained operation I expect to do
  ;;
  ;; $max Maximum distance to travel per activation in unit of pixels.
  ;; $max / $interval is the highest speed as which I want to go
  ;;
  ;; NOTE: (($max - $min) / $acceletaion-time) * $interval should be a small 
  ;; number for acceleration to feel smooth
  ma↑ (movemouse-accel-up 30 1000 10 80)
  ma← (movemouse-accel-left 30 1000 10 80)
  ma↓ (movemouse-accel-down 30 1000 10 80)
  ma→ (movemouse-accel-right 30 1000 10 80)
)

;; Not sure why, but on macOS if I 120 pixel as travel distance I get way
;; too fast scroll. 5 works.
(platform (macos)
  (defalias
    mwu (mwheel-down 60 5)
    mwd (mwheel-up 60 5)
    mwl (mwheel-left 60 5)
    mwr (mwheel-right 60 5)
  )
)
(platform (linux win winiov2 wintercept)
  (defalias
    mwu (mwheel-down 50 120)
    mwd (mwheel-up 50 120)
    mwl (mwheel-left 50 120)
    mwr (mwheel-right 50 120)
  )
)

;;
;; Special mappings from PC-style shortcuts to macOS shortcuts
;; On Linux/Windows it just maps these modifiers back the the same modifers.
;; On macOS it triggers special layers.
;;
(platform (linux win winiov2 wintercept)
  (defalias
    l_pc_lctl lctl
    l_pc_lalt lalt
    l_pc_lmet lmet
  )
)
(platform (macos)
  (defalias
    l_pc_lctl (multi lmet (layer-while-held pc_lctl_layer))
    l_pc_lalt (multi lalt (layer-while-held pc_lalt_layer))
    l_pc_lmet (multi lmet (layer-while-held pc_lmet_layer))
  )
)

;; Linux/Windows-style Ctrl-* shortcuts layer
;; Most of them correspond to Command-* shortcuts on macOS. 
;; So by default we send the Command key and introduce only a few exceptions
;; in this layer. See the `l_pc_lctl` alias.
;;
;; Specific-applications (e.g. terminal programs like neovim) that are
;; based heavily on Ctrl-* shortcuts should do application-level remapping
;; of Command to Ctrl.
;;
;; In the layer we configure a few exceptions.
(deflayermap (pc_lctl_layer)
  ;; In App navigation (e.g., browser):
  ;; Windows `Ctrl + Tab` -> macOS `Command + Tab`
  tab (multi (release-key lmet) lctl tab)
  ;; I already use directly `Command + Space` as shortcut.
  ;; Ctrl + Space is useful to some apps (e.g. trigger autocompletion in Vim)
  spc (multi (release-key lmet) lctl spc)
  
  ;; Text box shortcuts 
  ;; (e.g., Windows `Ctrl + Left` -> macOS `Option + Left`)
  left  (multi (release-key lmet) lalt left)
  right (multi (release-key lmet) lalt right)
  bspc  (multi (release-key lmet) lalt bspc)
  del   (multi (release-key lmet) lalt del)
  e lrld
)

(defvirtualkeys vk_alt_tab (multi lmet (macro tab)))

;; Linux/Windows-style Alt-* shortcuts layer
;; By default, retain the same `Alt` key behavior. See the `l_pc_lalt` alias.
;;
;; In the layer we configure a few exceptions.
(deflayermap (pc_lalt_layer)
  ;; Alt + F4 -> Command + Shift + W (Close Window)
  ;; Closest to Alt + F4.
  ;; Command + W only closes a single "tab" within a window.
  ;; Command + Q closes the program entirely (e.g., all the windows of a browser).
  ;; Give up... Not all apps support this. Accept that window closing on
  ;; macOS has different layers of semantics and get used to the new shortcuts.
  ;; f4 (multi (release-key lalt) lmet lsft w)

  ;; Application-window switching
  ;; Linux/Windows `Alt + Tab` -> `Command + Tab`
  ;; NOTE: we need to handle this case specially using virtual keys
  ;; because on macOS (well, actually also on Linux/Windows) the behaviour of 
  ;; Alt-Tab style switching is that if after the first switch the Alt key
  ;; is still pressed, then a floating window shows the existing application
  ;; windows.
  tab (multi (release-key lalt) (on-press press-virtualkey vk_alt_tab) (on-physical-idle 60 release-virtualkey vk_alt_tab))
  ;; Switching between windows of the same application
  ;; Linux/Windows `Alt + Grave` -> `Command + Grave`
  grave (multi (release-key lalt) lmet grave)

  ;; Browser previous/next page
  ;; E.g., Linux/Windows `Alt + Left` -> `Command + Left`
  left (multi (release-key lalt) lmet left)
  right (multi (release-key lalt) lmet right)
  )

;; Linux/Windows-style Super-* shortcuts layer
;; By default, retain the same `Super` key behavior. See the `l_pc_lmet` alias.
;;
;; In the layer we configure a few exceptions.
(deflayermap (pc_lmet_layer)
  ;; Lock screen
  ;; Linux/Windows `Super + L` -> `Command + Ctrl + Q`
  l (multi lmet lctl q)
  ;; Show desktop
  ;; Linux/Windows `Super + D` -> `F11`
  d (multi (release-key lmet) f11)

  ;; Focus and launch nth item on the system dock
  ;; Use this "hack" instead of properly configuring shortcuts to focus or 
  ;; launch specific applications.
  1 (multi (release-key lmet) (macro C-f3 home ret)) 
  2 (multi (release-key lmet) (macro C-f3 home right ret)) 
  3 (multi (release-key lmet) (macro C-f3 home right right ret)) 
  4 (multi (release-key lmet) (macro C-f3 home right right right ret)) 
  5 (multi (release-key lmet) (macro C-f3 home right right right right ret)) 
  6 (multi (release-key lmet) (macro C-f3 home right right right right right ret)) 
  7 (multi (release-key lmet) (macro C-f3 home right right right right right right ret)) 
  8 (multi (release-key lmet) (macro C-f3 home right right right right right right right ret)) 
)
